#include "WebRTCReceiver.h"

namespace WebCAMO {

WebRTCReceiver::WebRTCReceiver(std::shared_ptr<FrameBuffer> frameBuffer)
    : m_frameBuffer(frameBuffer) {}

WebRTCReceiver::~WebRTCReceiver() { Shutdown(); }

bool WebRTCReceiver::Initialize() {
  // TODO: Initialize WebRTC native library
  // For a full implementation, you would:
  // 1. Initialize PeerConnectionFactoryInterface
  // 2. Create PeerConnectionInterface with ICE servers
  // 3. Set up VideoTrackInterface to receive frames

  // For now, return true as a stub
  return true;
}

std::string WebRTCReceiver::CreateAnswer(const std::string &offer) {
  // TODO: Create actual SDP answer from offer
  // For a full implementation:
  // 1. Parse the SDP offer
  // 2. Set it as remote description
  // 3. Create and return the SDP answer

  // Stub: Return a placeholder
  // In reality, this would be generated by WebRTC

  // For testing without full WebRTC, you could implement
  // simple raw socket video streaming instead

  return R"(v=0
o=- 0 0 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE 0
m=video 9 UDP/TLS/RTP/SAVPF 96
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:stub
a=ice-pwd:stubpassword
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=setup:active
a=mid:0
a=recvonly
a=rtcp-mux
a=rtpmap:96 VP8/90000
)";
}

void WebRTCReceiver::AddIceCandidate(const std::string &sdpMid,
                                     int sdpMLineIndex,
                                     const std::string &candidate) {
  // TODO: Add ICE candidate to peer connection
  (void)sdpMid;
  (void)sdpMLineIndex;
  (void)candidate;
}

void WebRTCReceiver::OnVideoFrame(const uint8_t *data, int width, int height) {
  if (!m_frameBuffer)
    return;

  VideoFrame frame(width, height);
  frame.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                        std::chrono::system_clock::now().time_since_epoch())
                        .count();

  // Copy frame data (assuming RGBA)
  size_t size = width * height * 4;
  memcpy(frame.data.data(), data, std::min(size, frame.data.size()));

  m_frameBuffer->Push(std::move(frame));
}

void WebRTCReceiver::Shutdown() {
  m_connected = false;
  // TODO: Cleanup WebRTC resources
}

} // namespace WebCAMO
